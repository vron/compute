package main

import (
	"bufio"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
)

type vinfo struct {
	underlyingType string
	tdName         string
	typeSpec       string
}

func vi(a ...string) vinfo {
	return vinfo{
		underlyingType: a[0],
		tdName:         a[1],
		typeSpec:       a[2],
	}
}

var vtypes = []vinfo{
	vi("float", "float", ""),
	vi("int32_t", "int", "i"),
	vi("uint32_t", "uint", "u"),
}

var vsizes = []int{2, 3, 4}

func generateTypes(inp Input) {
	f, err := os.Create(filepath.Join(fOut, "types.hpp"))
	if err != nil {
		log.Fatalln(err)
	}
	defer f.Close()
	buf := bufio.NewWriter(f)
	defer buf.Flush()

	buf.WriteString("// Code generated DO NOT EDIT\n")
	buf.WriteString("\n\n")

	// Write some generiv defined
	buf.WriteString("#define INL  __attribute__((always_inline))\n\n")
	buf.WriteString(`enum __comp {
	_ind_X = 0,
	_ind_Y = 1,
	_ind_Z = 2,
	_ind_W = 3,
};


`)
	buf.WriteString("typedef int32_t Bool;\n\n")

	generateVectorTypes(buf)
	generateImageTypes(buf)
	generateCreateVectors(buf)
	generateBuiltinFunctions(buf)
	generateUserStructs(buf, inp)
}

func generateVectorTypes(buf *bufio.Writer) {
	// Forward decl.
	for _, typ := range vtypes {
		for _, size := range vsizes {
			fmt.Fprintf(buf, "typedef %v %vvec%v __attribute__((ext_vector_type(%v)));;\n", typ.underlyingType, typ.typeSpec, size, size)
		}
	}
	buf.WriteString("\n\n")
}

func compName(i int) string {
	switch i {
	case 0:
		return string('x')
	case 1:
		return string('y')
	case 2:
		return string('z')
	case 3:
		return string('w')
	}
	panic("bad length")
}

func generateImageTypes(buf *bufio.Writer) {
	// TODO: loop multiple image types, for now only support one...
	// TODO: can we add attributes such that the compiler will now the alignemnt of data (and chec in set_data), so it
	// can use aligned sse operations to store in e.g. a vec4 into it?

	buf.WriteString(`struct image2Drgba32f {
	float* data;
	int width;
  
	`)
	if types.Get("image2Drgba32f").apiType {
		buf.WriteString(`	void from_api(cpt_image2Drgba32f d) {
			this->data = (float*)d.data;
			this->width = d.width;
		};

		`)
	}
	buf.WriteString("};\n")

	buf.WriteString("\n\n")
}

func generateCreateVectors(buf *bufio.Writer) {
	// write the functions we use to create vectors, note that glsl supports 2
	// options:
	// 1 component only -> all fields have this value
	// same number of components as vector, aggregated from scalar
	// and vector parts.
	// This means that there are quite many options for constructors to generate, so
	// let us do that, we rely on clang dropping the definitions we do not use anyway
	// so lets create them all and not du any runtime stuff that might be slow..
	for _, typ := range vtypes {
		for _, size := range vsizes {
			printSingleCreate(buf, typ, size)
			printMultipeCreate(buf, typ, size)
		}
	}
	// we also need make_int and friends as effectively no-ops but generated by the translation
	scalarTypes := [][2]string{ /*{"bool", "bool"},*/ {"int", "int32_t"}, {"uint", "uint32_t"}, {"float", "float"}}
	for _, s := range scalarTypes {
		for _, t := range scalarTypes {
			fmt.Fprintf(buf, "%v INL make_%v(%v n) { return (%v)n; }; \n", s[1], s[0], t[1], s[1])
		}
	}

	buf.WriteString("\n\n")
}

func printSingleCreate(buf *bufio.Writer, typ vinfo, size int) {
	fmt.Fprintf(buf, "%vvec%v INL make_%vvec%v(%v v) { return ", typ.typeSpec, size, typ.typeSpec, size, typ.underlyingType)

	fmt.Fprintf(buf, "%vvec%v{", typ.typeSpec, size)
	for i := 0; i < size; i++ {
		fmt.Fprintf(buf, "v")
		if i != size-1 {
			buf.WriteString(", ")
		}
	}
	buf.WriteString("}; };\n")

}
func printMultipeCreate(buf *bufio.Writer, typ vinfo, size int) {
	options := []aopt{{1, "float"}, {1, "int32_t"}, {1, "uint32_t"}}
	for _, typ := range vtypes {
		for _, size := range vsizes {
			options = append(options, aopt{size, fmt.Sprintf("%vvec%v", typ.typeSpec, size)})
		}
	}
	sizes := make([][]aopt, 0)
	genPossibleSizes(&sizes, &[]aopt{}, size, options)
	for _, args := range sizes {
		// but each argument can also be of different sizes
		printCreate(buf, typ, size, args)
		_ = args
	}
}

func printCreate(buf *bufio.Writer, typ vinfo, size int, o []aopt) {
	fmt.Fprintf(buf, "%vvec%v INL make_%vvec%v(", typ.typeSpec, size, typ.typeSpec, size)
	for i, arg := range o {
		fmt.Fprintf(buf, "%v a%v", arg.typName, i)
		if i != len(o)-1 {
			buf.WriteString(", ")
		}
	}
	buf.WriteString(") { return ")
	fmt.Fprintf(buf, "%vvec%v{", typ.typeSpec, size)
	nod := -1
	for i, arg := range o {
		if arg.size == 1 {
			nod++
			if arg.typName != typ.underlyingType {
				fmt.Fprintf(buf, "(%v)", typ.underlyingType)
			}
			fmt.Fprintf(buf, "(a%v)", i)
			if nod != size-1 {
				buf.WriteString(", ")
			}
		} else {
			for j := 0; j < arg.size; j++ {
				nod++
				if arg.typName != typ.underlyingType { // this should be underlying type?
					fmt.Fprintf(buf, "(%v)", typ.underlyingType)
				}
				fmt.Fprintf(buf, "(a%v.%v)", i, compName(j))
				if nod != size-1 {
					buf.WriteString(", ")
				}
			}
		}
	}
	buf.WriteString("}; };\n")
}

type aopt struct {
	size    int
	typName string
}

// generate all ways in which we can choose sizes from options such
// that the total adds up to target
func genPossibleSizes(all *[][]aopt, current *[]aopt, target int, options []aopt) {
	if target == 0 {
		*all = append(*all, *current)
		return // done on this one
	}
	for _, o := range options {
		if o.size > target {
			continue
		}
		cd := make([]aopt, len(*current))
		copy(cd, *current)
		cd = append(cd, o)
		genPossibleSizes(all, &cd, target-o.size, options)
	}
}

func generateBuiltinFunctions(buf *bufio.Writer) {
	//buf.WriteString("void barrier();\n")

	fimageStoreLoad(buf)
	fAtomic(buf)
}

func fimageStoreLoad(buf *bufio.Writer) {
	// TODO: generate for types of images, also for non-2D images
	buf.WriteString(`void imageStore(image2Drgba32f image, ivec2 P, vec4 data) {
	int32_t index = 4*P.x+4*P.y*image.width;
	image.data[index + 0] = data.x;
	image.data[index + 1] = data.y;
	image.data[index + 2] = data.z;
	image.data[index + 3] = data.w;
}

`)
	buf.WriteString(`vec4 imageLoad(image2Drgba32f image, ivec2 P) {
	int32_t index = 4*P.x+4*P.y*image.width;
	return make_vec4(image.data[index + 0], image.data[index + 1], image.data[index + 2], image.data[index + 3]);
}

`)
}
func fAtomic(buf *bufio.Writer) {
	for _, t := range []string{"uint32_t", "int32_t"} {
		fmt.Fprintf(buf, "%v INL atomicAdd(%v *mem, %v data) {\n", t, t, t)
		fmt.Fprintf(buf, "\treturn __atomic_add_fetch(mem, data, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "%v INL atomicAnd(%v *mem, %v data) {\n", t, t, t)
		fmt.Fprintf(buf, "\treturn __atomic_and_fetch(mem, data, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "%v INL atomicOr(%v *mem, %v data) {\n", t, t, t)
		fmt.Fprintf(buf, "\treturn __atomic_or_fetch(mem, data, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "%v INL atomicXor(%v *mem, %v data) {\n", t, t, t)
		fmt.Fprintf(buf, "\treturn __atomic_xor_fetch(mem, data, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "%v INL atomicMin(%v *mem, %v data) {\n", t, t, t)
		fmt.Fprintf(buf, "\treturn __atomic_fetch_min(mem, data, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "%v INL atomicMax(%v *mem, %v data) {\n", t, t, t)
		fmt.Fprintf(buf, "\treturn __atomic_fetch_max(mem, data, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "}\n\n")

		fmt.Fprintf(buf, "%v INL atomicExchange(%v *mem, %v data) {\n", t, t, t)
		fmt.Fprintf(buf, "\treturn __atomic_exchange_n(mem, data, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "}\n\n")

		// TODO: Is this one really correct?!
		fmt.Fprintf(buf, "%v INL atomicCompSwap(%v *mem, %v compare, %v data) {\n", t, t, t, t)
		fmt.Fprintf(buf, "\t__atomic_compare_exchange_n(mem, &compare, data, true, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);\n")
		fmt.Fprintf(buf, "\treturn compare;\n")
		fmt.Fprintf(buf, "}\n\n")

	}

}

func generateUserStructs(buf *bufio.Writer, inp Input) {
	buf.WriteString("\n\n\n")

	for _, s := range types.UserStructs() {
		fmt.Fprintf(buf, "struct %v;\n", s.Name)
	}
	buf.WriteString("\n")
	for _, s := range types.UserStructs() {
		fmt.Fprintf(buf, "struct %v {// size=%v alignment=%v\n", s.Name, s.CType().Size.ByteSize, s.CType().Size.ByteAlignment)

		for _, f := range s.CType().Fields {
			//fmt.Fprintf(buf, "\t%v %v;  // size=%v alignment=%v offset=%v\n", f.Ty.ty.Name, f.Name)
			fmt.Fprintf(buf, "%v  // size=%v alignment=%v offset=%v\n", f.CxxFieldString(), f.Ty.Size.ByteSize, f.Ty.Size.ByteAlignment, f.ByteOffset)
		}

		// empty constructor
		fmt.Fprintf(buf, "\t %v () {};\n", s.Name)

		// write a constructor to allow function-style initialization
		//notused(vec3 ac[3], Bool bb, float cc) : aa{ac[0], ac[1], ac[2]}, bb(bb), cc(cc) {};

		fmt.Fprintf(buf, "\t%v(", s.Name)
		for i, f := range s.CType().Fields {
			// TODO: Must we allow type cases here to?
			arl := f.CxxArrayLen()
			ex := ""
			if arl > 0 {
				ex += fmt.Sprintf("[%v]", arl)
			}
			fmt.Fprintf(buf, "%v %v"+ex, f.Ty.ty.Name, f.Name)
			if i != len(s.CType().Fields)-1 {
				buf.WriteString(", ")
			}
		}
		buf.WriteString(") : ")
		for i, f := range s.CType().Fields {
			arl := f.CxxArrayLen()
			if arl > 0 {
				fmt.Fprintf(buf, "%v{", f.Name)
				fmt.Fprintf(buf, "%v[0]", f.Name)
				for j := 1; j < arl; j++ {
					fmt.Fprintf(buf, ", %v[%v]", f.Name, j)
				}
				fmt.Fprintf(buf, "}")
			} else {
				fmt.Fprintf(buf, "%v(%v)", f.Name, f.Name)
			}
			if i != len(s.CType().Fields)-1 {
				buf.WriteString(", ")
			}
		}
		fmt.Fprintf(buf, " {};\n")

		// we also need to construct a from_api function to copy over data from
		// the api structs - only arrays we enforce user to handle the alignment
		// WE simply declare it here and define it below, if we have to refer to
		// ourselves somewhere
		if s.apiType {
			fmt.Fprintf(buf, "\tvoid from_api(%v);\n", s.CType().Name)
		}

		buf.WriteString("};\n\n")
	}

	// Write implementation for the from api methods, copying field by field (rec if needed)
	for _, s := range types.UserStructs() {
		if s.apiType {
			fmt.Fprintf(buf, "void %v::from_api(%v d) {\n", s.Name, s.CType().Name)

			for _, cf := range s.CType().Fields {
				cf.CxxBinding(buf)
			}

			fmt.Fprintf(buf, "};\n\n")
		}

	}

	buf.WriteString("\n")
}

/*

func bDirect(arg InputArgument) string {
	return fmt.Sprintf("\tthis->%v = d.%v;\n", arg.CxxName(), arg.CName())
}

func bVec(size int) func(InputArgument) string {
	return func(arg InputArgument) string {
		// bind a value by copying vector data
		s := ""
		for i := 0; i < size; i++ {
			s += fmt.Sprintf("\tthis->%v.%v = d.%v[%v];\n", arg.CxxName(), compName(i), arg.CName(), i)
		}
		return s
	}
}


*/

func (cf CField) CxxBinding(buf io.Writer) {
	if cf.Ty.IsSlice {
		// slice type, the incomeing is *void and we assume everyhting is layed out, assign!
		fmt.Fprintf(buf, "\tthis->%v = (%v*)d.%v;\n", cf.Name, cf.Ty.ty.Name, cf.Name)
		return
	}
	if cf.Ty.ArrayLen == 0 {
		if len(cf.Ty.Fields) > 0 {
			// this is a struct, assign each one of them, this must be done recursively!
			fmt.Fprintf(buf, "\t(&(this->%v))->from_api(d.%v);\n", cf.Name, cf.Name)
			return
		}
		fmt.Fprintf(buf, "\tthis->%v = d.%v;\n", cf.Name, cf.Name)
		return
	}

	// so it is an array of stuff, do the same for each once of the elements, but as a temp hac
	// chec for the underlying type to set from that if needed
	arrlen := cf.CxxArrayLen()
	vecSize := cf.Ty.ArrayLen
	if arrlen > 0 {
		vecSize = cf.Ty.ArrayLen / arrlen
	} else {
		arrlen = 1
	}
	for i := 0; i < arrlen; i++ {
		if len(cf.Ty.Fields) > 0 {
			// this is a struct, assign each one of them, this must be done recursively!
			fmt.Fprintf(buf, "\t(&(this->%v[%v]))->from_api(d.%v[%v]);\n", cf.Name, i, cf.Name, i)
		} else {
			if arrlen > 1 {
				for j := 0; j < vecSize; j++ {
					fmt.Fprintf(buf, "\tthis->%v[%v][%v] = d.%v[%v];\n", cf.Name, j, i, cf.Name, i*vecSize+j)
				}
			} else {
				for j := 0; j < vecSize; j++ {
					fmt.Fprintf(buf, "\tthis->%v[%v] = d.%v[%v];\n", cf.Name, j, cf.Name, j)
				}
			}
		}
	}
}
